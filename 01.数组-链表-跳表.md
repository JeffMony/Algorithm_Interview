#### 1.计算盛水最多的容器
https://leetcode-cn.com/problems/container-with-most-water/ <br>
首先要想到暴力解法怎么做?<br>

对于一个数组,定义两个指针,一个头指针 i ,一个尾指针 j .<br>
头指针从头向尾指针靠近,尾指针从尾向头指针靠近.<br>
终止条件肯定是 i >= j<br>
靠近的过程中,底盘不断地变小--->(j - i)<br>
这时候iu可变的是高度,有两个可选择的高度--->(height[i] 和 height[j])<br>
当前要选择高度中最小的那一个,因为要求是盛水.<br>
根据分析,最终的公式是    **res = MAX(res , min(height[i], height[j]) (j - i))** <br>

```
class Solution {
    public int maxArea(int[] height) {
        if (height.length < 1) {
            return -1;
        }
        int i = 0;
        int j = height.length - 1;
        int res = -1;
        while(i < j) {
            int h = (height[i] > height[j]) ? height[j] : height[i];
            int tempRes = h * (j - i);
            res = (res > tempRes) ? res : tempRes;
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return res;
    }
}
```

**这个代码的时间复杂度是O(n)的,空间复杂度是O(1)的**

#### 2.移动零
https://leetcode-cn.com/problems/move-zeroes/ <br>
编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>
保持非0元素的相对顺序，这要求一定要从头顺序遍历。<br>
如果允许非0元素相对顺序变化，那可以从头尾两个指针遍历方法。<br>
但是现在需要保持相关顺序，只能从快慢指针的方法。

```
class Solution_012 {
    public void moveZeroes(int[] nums) {
        if (nums.length == 0 || nums.length == 1) {
            return;
        }
        int slow = 0;
        int quick = slow + 1;
        while(quick <= nums.length - 1) {
            if (nums[slow] != 0) {
                slow++;
                quick = slow + 1;
            } else {
                if (nums[quick] == 0) {
                    quick++;
                } else {
                    int temp = nums[slow];
                    nums[slow] = nums[quick];
                    nums[quick] = temp;
                }
            }
        }
    }
}
```

#### 3.爬楼梯
https://leetcode.com/problems/climbing-stairs/ <br>
这是一个典型的斐波拉契数列问题，通过递归可以很容的解决这个问题，但是递归的方案太耗时，重复计算太多了。肯定不是推荐的选择。
```
class Solution_013 {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        return climbStairs(n-1) + climbStairs(n-2);
    }
}
```
下面是正常的计算，不能导致额外的计算过程，可以省时间。
```
class Solution_013 {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        int num1;
        int num2 = 1;
        int res = 2;
        for(int index = 3; index <= n; index++) {
            num1 = num2;
            num2 = res;
            res = num1 + num2;
        }
        return res;
    }
}
```

#### 4.三数之和
https://leetcode-cn.com/problems/3sum/ <br>
这个题解讲得非常好。双指针法。<br>
https://leetcode-cn.com/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/ <br>
```
class Solution_014 {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        if (nums.length == 0) {
            return res;
        }
        //1.首先将数组排序
        Arrays.sort(nums);
        int target = 0;
        for (int first = 0; first < nums.length; first++) {
            //2.确定一个指针，其他两个数使用数组的双指针法
            if (first > 0 && (nums[first] == nums[first - 1])) {
                continue;
            }
            target = -nums[first];

            //3.下面两个数的确定使用数组双指针法
            int second = first + 1;
            int third = nums.length - 1;
            for (; second < nums.length; second++) {
                if (second > first + 1 && (nums[second] == nums[second - 1])) {
                    continue;
                }

                //4.因为排过序了，所以当大于target值，尾指针前移就行
                while(second < third && (nums[second] + nums[third]) > target) {
                    third--;
                }

                if (second == third) {
                    break;
                }
                if(nums[second] + nums[third] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    res.add(list);
                }
            }
        }
        return res;
    }
}
```

