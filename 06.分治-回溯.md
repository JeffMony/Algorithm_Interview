<!-- MarkdownTOC -->

- 1.括号生成
- 2.Pow\(x, n\)
- 3.数组的所有子集
- 4.牛顿迭代法
- 5.多数元素

<!-- /MarkdownTOC -->

#### 1.括号生成
https://leetcode-cn.com/problems/generate-parentheses/ <br>
暴力解法肯定都知道，就是将所有的 '('和')'生成序列都列出来，生成的种类会有很多个。<br>
但是不是所有的都能满足要求，那么生成的过程中会产生很多冗余的数据，如果能在生成的过程中做一些回溯，<br>
就是当前的序列如果已经不满足括号匹配的规则了，那就不需要继续排列下去了，那就剪枝，然后继续排列。<br>
这道题目用到的回溯的思想，下面的的算法：
> * open表示左括号的个数；
> * close表示右括号的个数；
```
class Solution_032 {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }

        if (open < max) {
            cur.append('(');
            backtrack(ans, cur, open+1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(')');
            backtrack(ans, cur, open, close+1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```
```
((()))
(()())
(())()
()(())
()()()
```

#### 2.Pow(x, n)
https://leetcode-cn.com/problems/powx-n/ <br>
注意一些特殊值就可以的。下面是递归的方式来求POW函数的。
```
class Solution_037 {
    public double myPow(double x, int n) {
        if (n < 0) {
            if (n == Integer.MIN_VALUE) {
                return 1.0 / (customPow(x, -(n + 1)) * x) ;
            }
            return 1.0 / customPow(x, -n);
        }
        return customPow(x, n);
    }

    private double customPow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return x;
        }
        double num = myPow(x, n/2);
        return num * num  * myPow(x, n - n/2 * 2);
    }}
```
不用递归，使用循环的方式如何实现？
```
class Solution {
    double quickMul(double x, long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
}
```

#### 3.数组的所有子集
https://leetcode-cn.com/problems/subsets/ <br>
回溯法，求一个有n的元素数组的所有子集合。
> * 集合的个数从0个到n个都是有可能的。
> * 假如有0个元素，遍历这种可能。
> * 假如有1个元素，遍历这种可能。
> * 假如有2个元素，遍历这种可能，遍历过程中包含着回溯：
```
第1步---->   1 , 2
第2步---->   先回溯到1，然后再次进行 1 , 3
第3步---->   先回溯到1，然后再次进行 1 , 4
......
```

```
class Solution_038 {
    private List<List<Integer>> res = new ArrayList();
    int k;

    private void backTrack(int curIndex, ArrayList<Integer> curSet, int[] nums) {
        if (curSet.size() == k) {
            res.add(new ArrayList<>(curSet));
        }
        for(int i = curIndex; i < nums.length; i++) {
            curSet.add(nums[i]);
            backTrack(i+1, curSet, nums);
            curSet.remove(curSet.size() - 1);
        }
    }

    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        for (k = 0; k < n + 1; ++k) {
            backTrack(0, new ArrayList<Integer>(), nums);
        }
        return res;
    }
}
```

#### 4.牛顿迭代法
http://www.matrix67.com/blog/archives/361 <br>
例如你想求4的开方，实际上就是求x^2 - 4 = 0;<br>
x-f(x)/(2x)就是一个比x更接近的近似值:<br>
4那个点是Xn 左边那个点是Xn-1<br>
求出f(x)在Xn处的一阶导:<br>
f'(Xn) = f(Xn)/(Xn-Xn-1)<br>
挪动挪动:<br>
Xn-1 = Xn – f(Xn)/f'(Xn)<br>
等式右边就是LZ的x-f(x)/(2x)<br>
图像上可以看出Xn-1比Xn更接近我们f(x)的根<br>
之所以可以用迭代法是因为中值定理, 用泰勒公式也可以推出这样的式子<br>
```
class Solution_039 {
    public int mySqrt(int x) {
        double res = (double)x;
        while(Math.abs(res - (res + x / res) / 2) >= 0.01) {
            res = (res + x / res) / 2;
        }
        return (int)res;
    }
}
```

#### 5.多数元素
https://leetcode-cn.com/problems/majority-element/description/ <br>
寻找数组中出现次数超过nums.length / 2次的元素。<br>
首先能想到的就是将数组排好序，取nums[nums.length / 2]就可以；<br>
但是直接排序比较慢，我们想到了快速排序，每次快排之后，就会确定一个元素的最终位置，<br>
那么每次快排之后我们确定一下partition的位置是不是nums.length / 2
```
class Solution_040 {
    public int majorityElement(int[] nums) {
        return quickSort(nums, 0, nums.length - 1);
    }

    public int quickSort(int[] nums, int low, int high) {
        if (high <= low) {
            return nums[nums.length / 2];
        }
        int pivot = partition(nums, low, high);
        if (pivot == nums.length / 2) {
            return nums[pivot];
        } else if (pivot > nums.length / 2){
            quickSort(nums, low, pivot - 1);
            return nums[nums.length / 2];
        } else {
            quickSort(nums, pivot + 1, high);
            return nums[nums.length / 2];
        }
    }

    private int partition(int[] nums, int low, int high) {
        int pivot = high;
        int count = low;
        for(int i = low; i < high; i++) {
            if(nums[i] < nums[pivot]) {
                int temp = nums[count];
                nums[count] = nums[i];
                nums[i] = temp;
                count++;
            }
         }
         int temp = nums[count];
         nums[count] = nums[pivot];
         nums[pivot] = temp;
         return count;
    }
}
```
