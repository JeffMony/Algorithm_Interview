<!-- MarkdownTOC -->

- 1.括号生成
- 2.Pow\(x, n\)
- 3.数组的所有子集

<!-- /MarkdownTOC -->

#### 1.括号生成
https://leetcode-cn.com/problems/generate-parentheses/ <br>
暴力解法肯定都知道，就是将所有的 '('和')'生成序列都列出来，生成的种类会有很多个。<br>
但是不是所有的都能满足要求，那么生成的过程中会产生很多冗余的数据，如果能在生成的过程中做一些回溯，<br>
就是当前的序列如果已经不满足括号匹配的规则了，那就不需要继续排列下去了，那就剪枝，然后继续排列。<br>
这道题目用到的回溯的思想，下面的的算法：
> * open表示左括号的个数；
> * close表示右括号的个数；
```
class Solution_032 {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }

        if (open < max) {
            cur.append('(');
            backtrack(ans, cur, open+1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(')');
            backtrack(ans, cur, open, close+1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}
```
```
((()))
(()())
(())()
()(())
()()()
```

#### 2.Pow(x, n)
https://leetcode-cn.com/problems/powx-n/ <br>
注意一些特殊值就可以的。下面是递归的方式来求POW函数的。
```
class Solution_037 {
    public double myPow(double x, int n) {
        if (n < 0) {
            if (n == Integer.MIN_VALUE) {
                return 1.0 / (customPow(x, -(n + 1)) * x) ;
            }
            return 1.0 / customPow(x, -n);
        }
        return customPow(x, n);
    }

    private double customPow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return x;
        }
        double num = myPow(x, n/2);
        return num * num  * myPow(x, n - n/2 * 2);
    }}
```
不用递归，使用循环的方式如何实现？
```
class Solution {
    double quickMul(double x, long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
}
```

#### 3.数组的所有子集
https://leetcode-cn.com/problems/subsets/ <br>
