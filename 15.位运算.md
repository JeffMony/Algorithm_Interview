<!-- MarkdownTOC -->

- 1.计算二进制中1的个数
- 2.求数是否是2的幂
- 3.颠倒二进制位

<!-- /MarkdownTOC -->


#### 1.计算二进制中1的个数
https://leetcode-cn.com/problems/number-of-1-bits/ <br>
```
public class Solution_050 {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        int mask=1;
        for(int i=0; i<32; i++) {
            if ((mask & n) != 0) {
                count++;
            }
            mask <<= 1;
        }
        return count;
    }
}
```
正常的思维运算，要明白，无符号整数的含义，Integer.MAX_VALUE和Integer.MIN_VALUE是有符号数。
```
class Solution_051 {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        if ((n & Integer.MIN_VALUE) != 0) {
            count = 1;
            n &= Integer.MAX_VALUE;
        }
        while( n != 0) {
            if ((n % 2) != 0) {
                count++;
            }
            n >>= 1;
        }
        return count;
    }
}
```

#### 2.求数是否是2的幂
https://leetcode-cn.com/problems/power-of-two/ <br>
```
class Solution_052 {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) {
            return false;
        }
        while(n != 0) {
            if (n == 1) {
                return true;
            }
            if ((n % 2) != 0) {
                return false;
            }
            n /= 2;
        }
        return true;
    }
}
```

#### 3.颠倒二进制位
https://leetcode-cn.com/problems/reverse-bits/ <br>
n & 1 表示取二进制最后一位<br>
n >>> 1 表示无符号右移一位<br>
```
public class Solution_053 {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 31; n != 0; i--) {
            res += (n & 1) << i;
            n >>>= 1;
        }
        return res;
    }
}
```
