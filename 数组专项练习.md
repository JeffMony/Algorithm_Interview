
### 介绍
数组专项是专门研究leetcode上数组相关的题目，全是自己的学习心得。

#### 1. 两数之和
[https://leetcode-cn.com/problems/two-sum/](https://leetcode-cn.com/problems/two-sum/)<br>
关键点：
> * 输出的顺序不作要求
> * 数组中同一个元素在答案里不能重复出现

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
```

#### 4. 寻找两个正序数组的中位数
[https://leetcode-cn.com/problems/median-of-two-sorted-arrays/](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)<br>
关键点：
> * 这是两个有序数组
> * 返回是两个合并后数组的中位数，但是合并操作肯定不能做，不然很耗时
> * 理解一下中位数的概念：不是平均是，是排序在最中间的那个数，如果最中间有两个数，那就对这两个数求平均


两个数组是有序的，中位数可能有1个，也有可能有两个，总数为奇数的中位数是一个，总数为偶数的中位数有两个。
```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length = nums1.length + nums2.length;
        int compareLength = (length + 1) / 2;
        int[] result = new int[compareLength + 1];
        System.out.println("compareLength = " +compareLength);
        int num1 = 0, num2 = 0;

        int i1 = 0, i2 = 0;
        int k = 0;

        while (i1 < nums1.length && i2 < nums2.length && k <= compareLength) {
            if (nums1[i1] < nums2[i2]) {
                result[k++] = nums1[i1++];
            } else {
                result[k++] = nums2[i2++];
            }
        }

        System.out.println("i1="+i1+", i2="+i2+", k="+k);

        while (i1 < nums1.length && k <= compareLength) {
            result[k++] = nums1[i1++];
        }

        while (i2 < nums2.length && k <= compareLength) {
            result[k++] = nums2[i2++];
        }

        for (int i = 0; i < compareLength + 1; i++) {
            System.out.println(result[i]);
        }

        if (length % 2 == 1) {
            return result[compareLength - 1];
        }
        return (result[compareLength] + result[compareLength - 1]) * 1.0 / 2;

    }
}
```

#### 11. 盛最多水的容器
[https://leetcode-cn.com/problems/container-with-most-water/](https://leetcode-cn.com/problems/container-with-most-water/) <br>

这是典型的双指针法

```
class Solution {
    public int maxArea(int[] height) {
        if (height.length < 1) {
            return -1;
        }
        int low = 0;
        int high = height.length - 1;
        int max = 0;
        while(low < high) {
            int h = Math.min(height[low], height[high]);
            max = Math.max(max, h * (high - low));
            if (height[low] > height[high]) {
                high--;
            } else {
                low++;
            }
        }
        return max;
    }
}
```

