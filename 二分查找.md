二分查找的模板代码：
```
# Python
left, right = 0, len(array) - 1 
while left <= right: 
      mid = (left + right) / 2 
      if array[mid] == target: 
            # find the target!! 
            break or return result 
      elif array[mid] < target: 
            left = mid + 1 
      else: 
            right = mid - 1
```

#### 1.x的平方根
https://leetcode-cn.com/problems/sqrtx/ <br>
不能使用库函数,那就要使用二分法不断逼近开方,注意浮点型数据都是有精度的.
```
class Solution_6 {
    int s;

    public int mySqrt(int x) {
        s=x;
        if(x==0) {
            return 0;
        }
        return ((int)(sqrts(x)));
    }

    private double sqrts(double x){
        double res = (x + s / x) / 2;
        if (Math.abs(res - x) < 0.000001) {
            return x;
        } else {
            return sqrts(res);
        }
    }
}
```

#### 2.有效的完全平方数
https://leetcode-cn.com/problems/valid-perfect-square/ <br>
这道题其实是上面一道题目的加强版.<br>
假设当前的num是完全的平方数,那么上面的二分法计算,可能会得到两个逼近最终完全平方数的整型值,在最终计算的考虑进去就可以的.
```
class Solution_7 {
    public boolean isPerfectSquare(int num) {
        int sqrtNum = mySqrt(num);
        if ((sqrtNum * sqrtNum == num) || (sqrtNum* sqrtNum + 2*sqrtNum +1== num)) {
            return true;
        }
        return false;
    }

    int s;

    private int mySqrt(int x) {
        s=x;
        if(x==0) {
            return 0;
        }
        return ((int)(sqrts(x)));
    }

    private double sqrts(double x){
        double res = (x + s / x) / 2;
        if (Math.abs(res - x) < 0.000001) {
            return x;
        } else {
            return sqrts(res);
        }
    }
}
```

#### 3.搜索旋转排序数组
https://leetcode-cn.com/problems/search-in-rotated-sorted-array/ <br>
这道题目要求时间复杂度必须是O(logn),那么肯定要使用二分查找法,已知二分查找法是在有序数组中使用的,本地是旋转有序数组.
> * 如果能找到旋转的地方,然后分治搜索,问题不就可以迎刃而解了吗?

