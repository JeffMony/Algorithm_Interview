<!-- MarkdownTOC -->

- 1.有效的括号
- 2.最小栈
- 3.柱状图中最大的矩形
- 优先队列
- 双端队列

<!-- /MarkdownTOC -->

#### 1.有效的括号
https://leetcode-cn.com/problems/valid-parentheses/ <br>

括号匹配问题是典型的栈的问题。这儿的匹配项还是有点少，只有'(', ')', '[', ']', '{', '}'这几种选择，<br>
所以下面的代码也算是比较清晰的。

```
class Solution_2 {

    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();
        char[] arr = s.toCharArray();
        for (char c : arr) {
            if ( c == '(') {
                stack.push(')');
            } else if ( c == '[') {
                stack.push(']');
            } else if ( c == '{') {
                stack.push('}');
            } else if (stack.isEmpty() || c != stack.pop() ) {
                return false;
            }
        }
        return stack.isEmpty();
    }
}
```

#### 2.最小栈
https://leetcode-cn.com/problems/min-stack/ <br>
本题当然可以使用java中的Stack结构，但是Stack结构中没有getMin函数，也就是本题的核心要点是希望扩展Stack函数，实现getMin方法。<br>
当然高效的方式最好是push的时候就计算好，但是也别忘了如果pop的是最小值，那就要重新计算最小值了。<br>
下面这种实现方式重点在pop函数中了。
```
class MinStack {
    private int mMinValue;
    private Stack<Integer> mStack;
    /** initialize your data structure here. */
    public MinStack() {
        mMinValue = Integer.MAX_VALUE;
        mStack  = new Stack<Integer>();
    }
    
    public void push(int x) {
        if (mMinValue > x) {
            mMinValue = x;
        }
        mStack.push(x);
    }
    
    public void pop() {
        if (mStack.size() < 1) {
            return;
        }
        int ret = mStack.pop();
        if (ret <= mMinValue) {
            mMinValue = mMinValue = Integer.MAX_VALUE;
            Stack tempStack = new Stack<Integer>();
            while(!mStack.isEmpty()) {
                tempStack.push(mStack.pop());
            }
            while(!tempStack.isEmpty()) {
                push((int)tempStack.pop());
            }
        }
    }
    
    public int top() {
        return mStack.peek();
    }
    
    public int getMin() {
        return mMinValue;
    }
}
```

但是还有更加简单的实现方式，不用维护复杂的pop函数，直接在push的时候判断一下，如果push的是当前的最小值，那么多记录一次。实现代码如下，真是比较精妙的实现方式。
```
class MinStack {
    private int mMinValue;
    private Stack<Integer> mStack;
    /** initialize your data structure here. */
    public MinStack() {
        mMinValue = Integer.MAX_VALUE;
        mStack  = new Stack<Integer>();
    }
    
    public void push(int x) {
        if(mMinValue >= x){
            mStack.push(mMinValue);
            mMinValue = x;
        }
        mStack.push(x);
    }

    public void pop() {
        if(mStack.pop() == mMinValue){
            mMinValue = mStack.pop();
        }
    }
    
    public int top() {
        return mStack.peek();
    }
    
    public int getMin() {
        return mMinValue;
    }
}
```

#### 3.柱状图中最大的矩形
https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ <br>
这道题的解决思路太厉害了，使用栈的思路来解决。<br>
https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/ <br>
定义了两个数组left[]和right[]:
> * left[]表示当前i值最大的矩形的左边界
> * right[]表示当前值最大的矩形的右边界
> * 用一个stack来辅助求出left[]和right[]
> * 我们只要记住一点，遍历数组heights[]，如果发现heights[i] >= height[i+1]，i索引的最大矩形肯定不会向右扩展了。
```
class Solution_024 {
    public int largestRectangleArea(int[] heights) {
        int length = heights.length;
        int[] left = new int[length];
        int[] right = new int[length];
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = 0; i < length; i++) {
            while(!stack.isEmpty() && (heights[stack.peek()] >= heights[i])) {
                stack.pop();
            }
            left[i] = (stack.isEmpty()) ? -1 : stack.peek();
            stack.push(i);
        }

        stack.clear();
        for (int i = length - 1; i >= 0; i--) {
            while(!stack.isEmpty() && (heights[stack.peek()] >= heights[i])) {
                stack.pop();
            }
            right[i] = (stack.isEmpty()) ? length : stack.peek();
            stack.push(i);
        }

        int res = 0;
        for (int i = 0; i < length; i++) {
            int temp = (right[i] - left[i] - 1) * heights[i];
            res = Math.max(res, temp);
        }
        return res;
    }
}
```
### 优先队列
### 双端队列
